# Splitting value types

There is extra information that needs to be passed around during static evaluation and compilation.

Currently, the Value type represents all values and operations, so for compile-time evaluation, the
evaluator needs to keep a parallel data structure, which is inefficient and awkward whenever the 
values pass through any method calls (external to the evaluator).

## Idea

Split the value types into two:

1. ASTValue
2. Value

Q: Should we split it into three - ASTValue, CValue, RValue? If we don't need to - it's best not to.

The ASTValue type would only represent the source code - it will be generated by the parser +
any actual Values can be "unparsed" into ASTValues.

The interpreter and code generator will work with the Value types.

Q: Should converting ASTValue->Value be done before interpretation, or at the same time?
Ideally, these should be separate, which means this translation step should be Scope-aware.

### What should Value contain that it didn't previously?

- Scope for lambdas and unbound variables
- Whether a lambda is fully evaluated (can this be done statically?)
- PartialStruct type? Or should this be a `Native` value?
- codeValue and realValue? Or should this be part of the interpreter?
- NameReference should contain `Variable` instead of `String`
- Used variable names. Or should this be part of the interpreter?

### FunctionBinding

```ruby
factory = () {
  a = UUID.new 

  () { a }
}

factory() #=> FunctionBinding () { a }, where a = 1234
factory() #=> FunctionBinding () { a }, where a = 4321
```

How do we convert FunctionBinding->ASTValue?

1. Inline all the variable references if they are out of scope?
2. Convert variable references to `let`s if they are out of scope
